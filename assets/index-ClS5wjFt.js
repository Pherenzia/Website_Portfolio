import{c as A}from"./index-DqXSQ5On.js";import{r as g}from"./vendor-BtEn6V6c.js";/**
 * @license lucide-react v0.294.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const $=A("MapPin",[["path",{d:"M20 10c0 6-8 12-8 12s-8-6-8-12a8 8 0 0 1 16 0Z",key:"2oe9fu"}],["circle",{cx:"12",cy:"10",r:"3",key:"ilqhr7"}]]);var w=new Map,b=new WeakMap,E=0,V=void 0;function m(e){return e?(b.has(e)||(E+=1,b.set(e,E.toString())),b.get(e)):"0"}function O(e){return Object.keys(e).sort().filter(t=>e[t]!==void 0).map(t=>`${t}_${t==="root"?m(e.root):e[t]}`).toString()}function T(e){const t=O(e);let n=w.get(t);if(!n){const c=new Map;let u;const i=new IntersectionObserver(s=>{s.forEach(r=>{var o;const v=r.isIntersecting&&u.some(f=>r.intersectionRatio>=f);e.trackVisibility&&typeof r.isVisible>"u"&&(r.isVisible=v),(o=c.get(r.target))==null||o.forEach(f=>{f(v,r)})})},e);u=i.thresholds||(Array.isArray(e.threshold)?e.threshold:[e.threshold||0]),n={id:t,observer:i,elements:c},w.set(t,n)}return n}function _(e,t,n={},c=V){if(typeof window.IntersectionObserver>"u"&&c!==void 0){const o=e.getBoundingClientRect();return t(c,{isIntersecting:c,target:e,intersectionRatio:typeof n.threshold=="number"?n.threshold:0,time:0,boundingClientRect:o,intersectionRect:o,rootBounds:o}),()=>{}}const{id:u,observer:i,elements:s}=T(n),r=s.get(e)||[];return s.has(e)||s.set(e,r),r.push(t),i.observe(e),function(){r.splice(r.indexOf(t),1),r.length===0&&(s.delete(e),i.unobserve(e)),s.size===0&&(i.disconnect(),w.delete(u))}}function j({threshold:e,delay:t,trackVisibility:n,rootMargin:c,root:u,triggerOnce:i,skip:s,initialInView:r,fallbackInView:o,onChange:v}={}){var f;const[h,x]=g.useState(null),l=g.useRef(v),[R,I]=g.useState({inView:!!r,entry:void 0});l.current=v,g.useEffect(()=>{if(s||!h)return;let d;return d=_(h,(S,y)=>{I({inView:S,entry:y}),l.current&&l.current(S,y),y.isIntersecting&&i&&d&&(d(),d=void 0)},{root:u,rootMargin:c,threshold:e,trackVisibility:n,delay:t},o),()=>{d&&d()}},[Array.isArray(e)?e.toString():e,h,u,c,i,s,n,o,t]);const p=(f=R.entry)==null?void 0:f.target,M=g.useRef(void 0);!h&&p&&!i&&!s&&M.current!==p&&(M.current=p,I({inView:!!r,entry:void 0}));const a=[x,R.inView,R.entry];return a.ref=a[0],a.inView=a[1],a.entry=a[2],a}export{$ as M,j as u};
